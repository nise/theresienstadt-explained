/* jquery.panzoom.min.js 3.2.2 (c) Timmy Willison - MIT License */
!(function (a, b) { typeof define === 'function' && define.amd ? define(['jquery'], c => b(a, c)) : typeof exports === 'object' ? b(a, require('jquery')) : b(a, a.jQuery) }(typeof window !== 'undefined' ? window : this, (a, b) => {
  function c(a, b) { for (let c = a.length; --c;) if (Math.round(+a[c]) !== Math.round(+b[c])) return !1; return !0 } function d(a) { const c = { range: !0, animate: !0 }; return typeof a === 'boolean' ? c.animate = a : b.extend(c, a), c } function e(a, c, d, e, f, g, h, i, j) { b.type(a) === 'array' ? this.elements = [+a[0], +a[2], +a[4], +a[1], +a[3], +a[5], 0, 0, 1] : this.elements = [a, c, d, e, f, g, h || 0, i || 0, j || 1] } function f(a, b, c) { this.elements = [a, b, c] } function g(a, c) {
    if (!(this instanceof g)) return new g(a, c); a.nodeType !== 1 && b.error('Panzoom called on non-Element node'), b.contains(h, a) || b.error('Panzoom element must be attached to the document'); const d = b.data(a, i); if (d) return d; this.options = c = b.extend({}, g.defaults, c), this.elem = a; const e = this.$elem = b(a); this.$set = c.$set && c.$set.length ? c.$set : e, this.$doc = b(a.ownerDocument || h), this.$parent = e.parent(), this.parent = this.$parent[0], this.isSVG = n.test(a.namespaceURI) && a.nodeName.toLowerCase() !== 'svg', this.panning = !1, this._buildTransform(), this._transform = b.cssProps.transform.replace(m, '-$1').toLowerCase(), this._buildTransition(), this.resetDimensions(); const f = b(),
      j = this; b.each(['$zoomIn', '$zoomOut', '$zoomRange', '$reset'], (a, b) => { j[b] = c[b] || f }), this.enable(), this.scale = this.getMatrix()[0], this._checkPanWhenZoomed(), b.data(a, i, this)
  } var h = a.document,
    i = '__pz__',
    j = Array.prototype.slice,
    k = /trident\/7./i,
    l = (function () { if (k.test(navigator.userAgent)) return !1; const a = h.createElement('input'); return a.setAttribute('oninput', 'return'), typeof a.oninput === 'function' }()),
    m = /([A-Z])/g,
    n = /^http:[\w\.\/]+svg$/,
    o = '(\\-?\\d[\\d\\.e-]*)',
    p = '\\,?\\s*',
    q = new RegExp(`^matrix\\(${o}${p}${o}${p}${o}${p}${o}${p}${o}${p}${o}\\)$`); return e.prototype = {
    x(a) {
      const b = a instanceof f,
        c = this.elements,
        d = a.elements; return b && d.length === 3 ? new f(c[0] * d[0] + c[1] * d[1] + c[2] * d[2], c[3] * d[0] + c[4] * d[1] + c[5] * d[2], c[6] * d[0] + c[7] * d[1] + c[8] * d[2]) : d.length === c.length && new e(c[0] * d[0] + c[1] * d[3] + c[2] * d[6], c[0] * d[1] + c[1] * d[4] + c[2] * d[7], c[0] * d[2] + c[1] * d[5] + c[2] * d[8], c[3] * d[0] + c[4] * d[3] + c[5] * d[6], c[3] * d[1] + c[4] * d[4] + c[5] * d[7], c[3] * d[2] + c[4] * d[5] + c[5] * d[8], c[6] * d[0] + c[7] * d[3] + c[8] * d[6], c[6] * d[1] + c[7] * d[4] + c[8] * d[7], c[6] * d[2] + c[7] * d[5] + c[8] * d[8])
    },
    inverse() {
      const a = 1 / this.determinant(),
        b = this.elements; return new e(a * (b[8] * b[4] - b[7] * b[5]), a * -(b[8] * b[1] - b[7] * b[2]), a * (b[5] * b[1] - b[4] * b[2]), a * -(b[8] * b[3] - b[6] * b[5]), a * (b[8] * b[0] - b[6] * b[2]), a * -(b[5] * b[0] - b[3] * b[2]), a * (b[7] * b[3] - b[6] * b[4]), a * -(b[7] * b[0] - b[6] * b[1]), a * (b[4] * b[0] - b[3] * b[1]))
    },
    determinant() { const a = this.elements; return a[0] * (a[8] * a[4] - a[7] * a[5]) - a[3] * (a[8] * a[1] - a[7] * a[2]) + a[6] * (a[5] * a[1] - a[4] * a[2]) },
  }, f.prototype.e = e.prototype.e = function (a) { return this.elements[a] }, g.rmatrix = q, g.defaults = {
    eventNamespace: '.panzoom', transition: !0, cursor: 'move', disablePan: !1, disableZoom: !1, disableXAxis: !1, disableYAxis: !1, which: 1, increment: 0.3, linearZoom: !1, panOnlyWhenZoomed: !1, minScale: 0.3, maxScale: 6, rangeStep: 0.05, duration: 200, easing: 'ease-in-out', contain: !1,
  }, g.prototype = {
    constructor: g,
    instance() { return this },
    enable() { this._initStyle(), this._bind(), this.disabled = !1 },
    disable() { this.disabled = !0, this._resetStyle(), this._unbind() },
    isDisabled() { return this.disabled },
    destroy() { this.disable(), b.removeData(this.elem, i) },
    resetDimensions() {
      this.container = this.parent.getBoundingClientRect(); const a = this.elem,
        c = a.getBoundingClientRect(),
        d = Math.abs(this.scale); this.dimensions = {
        width: c.width,
        height: c.height,
        left: b.css(a, 'left', !0) || 0,
        top: b.css(a, 'top', !0) || 0,
        border: {
          top: b.css(a, 'borderTopWidth', !0) * d || 0, bottom: b.css(a, 'borderBottomWidth', !0) * d || 0, left: b.css(a, 'borderLeftWidth', !0) * d || 0, right: b.css(a, 'borderRightWidth', !0) * d || 0,
        },
        margin: { top: b.css(a, 'marginTop', !0) * d || 0, left: b.css(a, 'marginLeft', !0) * d || 0 },
      }
    },
    reset(a) { a = d(a); const b = this.setMatrix(this._origTransform, a); a.silent || this._trigger('reset', b) },
    resetZoom(a) { a = d(a); const b = this.getMatrix(this._origTransform); a.dValue = b[3], this.zoom(b[0], a) },
    resetPan(a) { const b = this.getMatrix(this._origTransform); this.pan(b[4], b[5], d(a)) },
    setTransform(a) { for (let c = this.$set, d = c.length; d--;)b.style(c[d], 'transform', a), this.isSVG && c[d].setAttribute('transform', a) },
    getTransform(a) {
      const c = this.$set,
        d = c[0]; return a ? this.setTransform(a) : (a = b.style(d, 'transform'), !this.isSVG || a && a !== 'none' || (a = b.attr(d, 'transform') || 'none')), a === 'none' || q.test(a) || this.setTransform(a = b.css(d, 'transform')), a || 'none'
    },
    getMatrix(a) { const b = q.exec(a || this.getTransform()); return b && b.shift(), b || [1, 0, 0, 1, 0, 0] },
    getScale(a) { return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2)) },
    setMatrix(a, c) {
      if (!this.disabled) {
        c || (c = {}), typeof a === 'string' && (a = this.getMatrix(a)); const d = this.getScale(a),
          e = typeof c.contain !== 'undefined' ? c.contain : this.options.contain; if (e) {
          let f = c.dims; f || (this.resetDimensions(), f = this.dimensions); let g, h, i,
            j = this.container,
            k = f.width,
            l = f.height,
            m = j.width,
            n = j.height,
            o = m / k,
            p = n / l; this.$parent.css('textAlign') !== 'center' || b.css(this.elem, 'display') !== 'inline' ? (i = (k - this.elem.offsetWidth) / 2, g = i - f.border.left, h = k - m - i + f.border.right) : g = h = (k - m) / 2; const q = (l - n) / 2 + f.border.top,
            r = (l - n) / 2 - f.border.top - f.border.bottom; e === 'invert' || e === 'automatic' && o < 1.01 ? a[4] = Math.max(Math.min(a[4], g - f.border.left), -h) : a[4] = Math.min(Math.max(a[4], g), -h), e === 'invert' || e === 'automatic' && p < 1.01 ? a[5] = Math.max(Math.min(a[5], q - f.border.top), -r) : a[5] = Math.min(Math.max(a[5], q), -r)
        } if (c.animate !== 'skip' && this.transition(!c.animate), c.range && this.$zoomRange.val(d), this.options.disableXAxis || this.options.disableYAxis) { const s = this.getMatrix(); this.options.disableXAxis && (a[4] = s[4]), this.options.disableYAxis && (a[5] = s[5]) } return this.setTransform(`matrix(${a.join(',')})`), this.scale = d, this._checkPanWhenZoomed(d), c.silent || this._trigger('change', a), a
      }
    },
    isPanning() { return this.panning },
    transition(a) { if (this._transition) for (let c = a || !this.options.transition ? 'none' : this._transition, d = this.$set, e = d.length; e--;)b.style(d[e], 'transition') !== c && b.style(d[e], 'transition', c) },
    pan(a, b, c) { if (!this.options.disablePan) { c || (c = {}); let d = c.matrix; d || (d = this.getMatrix()), c.relative && (a += +d[4], b += +d[5]), d[4] = a, d[5] = b, this.setMatrix(d, c), c.silent || this._trigger('pan', d[4], d[5]) } },
    zoom(a, c) {
      typeof a === 'object' ? (c = a, a = null) : c || (c = {}); const d = b.extend({}, this.options, c); if (!d.disableZoom) {
        let g = !1,
          h = d.matrix || this.getMatrix(),
          i = new e(h),
          j = this.getScale(h); typeof a !== 'number' ? (a = d.linearZoom ? 1 + d.increment * (a ? -1 : 1) / j : a ? 1 / (1 + d.increment) : 1 + d.increment, g = !0) : a = 1 / j, a = Math.max(Math.min(a, d.maxScale / j), d.minScale / j); const k = i.x(new e(a, 0, 0, 0, typeof d.dValue === 'number' ? d.dValue / j : a, 0)),
          l = d.focal; if (l && !d.disablePan) {
          this.resetDimensions(); let m = d.dims = this.dimensions,
            n = l.clientX,
            o = l.clientY; this.isSVG || (n -= m.width / j / 2, o -= m.height / j / 2); let p = new f(n, o, 1),
            q = this.parentOffset || this.$parent.offset(),
            r = new e(1, 0, q.left - this.$doc.scrollLeft(), 0, 1, q.top - this.$doc.scrollTop()),
            s = i.inverse().x(r.inverse().x(p)); i = i.x(new e([a, 0, 0, a, 0, 0])), p = r.x(i.x(s)), h[4] = +h[4] + (n - p.e(0)), h[5] = +h[5] + (o - p.e(1))
        }h[0] = k.e(0), h[1] = k.e(3), h[2] = k.e(1), h[3] = k.e(4), this.setMatrix(h, { animate: typeof d.animate !== 'undefined' ? d.animate : g, range: !d.noSetRange }), d.silent || this._trigger('zoom', a, d)
      }
    },
    option(a, c) { let d; if (!a) return b.extend({}, this.options); if (typeof a === 'string') { if (arguments.length === 1) return void 0 !== this.options[a] ? this.options[a] : null; d = {}, d[a] = c } else d = a; this._setOptions(d) },
    _setOptions(a) { b.each(a, b.proxy(function (a, c) { switch (a) { case 'disablePan': this._resetStyle(); case '$zoomIn': case '$zoomOut': case '$zoomRange': case '$reset': case 'disableZoom': case 'onStart': case 'onChange': case 'onZoom': case 'onPan': case 'onEnd': case 'onReset': case 'eventNamespace': this._unbind() } switch (this.options[a] = c, a) { case 'disablePan': this._initStyle(); case '$zoomIn': case '$zoomOut': case '$zoomRange': case '$reset': this[a] = c; case 'disableZoom': case 'onStart': case 'onChange': case 'onZoom': case 'onPan': case 'onEnd': case 'onReset': case 'eventNamespace': this._bind(); break; case 'cursor': b.style(this.elem, 'cursor', c); break; case 'minScale': this.$zoomRange.attr('min', c); break; case 'maxScale': this.$zoomRange.attr('max', c); break; case 'rangeStep': this.$zoomRange.attr('step', c); break; case 'startTransform': this._buildTransform(); break; case 'duration': case 'easing': this._buildTransition(); case 'transition': this.transition(); break; case 'panOnlyWhenZoomed': this._checkPanWhenZoomed(); break; case '$set': c instanceof b && c.length && (this.$set = c, this._initStyle(), this._buildTransform()) } }, this)) },
    _checkPanWhenZoomed(a) { const b = this.options; if (b.panOnlyWhenZoomed) { a || (a = this.getMatrix()[0]); const c = a <= b.minScale; b.disablePan !== c && this.option('disablePan', c) } },
    _initStyle() { let a = { 'transform-origin': this.isSVG ? '0 0' : '50% 50%' }; this.options.disablePan || (a.cursor = this.options.cursor), this.$set.css(a); const c = this.$parent; c.length && !b.nodeName(this.parent, 'body') && (a = { overflow: 'hidden' }, c.css('position') === 'static' && (a.position = 'relative'), c.css(a)) },
    _resetStyle() { this.$elem.css({ cursor: '', transition: '' }), this.$parent.css({ overflow: '', position: '' }) },
    _bind() {
      let a = this,
        c = this.options,
        d = c.eventNamespace,
        e = `mousedown${d} pointerdown${d} MSPointerDown${d}`,
        f = `touchstart${d} ${e}`,
        h = `touchend${d} click${d} pointerup${d} MSPointerUp${d}`,
        i = {},
        j = this.$reset,
        k = this.$zoomRange; if (b.each(['Start', 'Change', 'Zoom', 'Pan', 'End', 'Reset'], function () { const a = c[`on${this}`]; b.isFunction(a) && (i[`panzoom${this.toLowerCase()}${d}`] = a) }), c.disablePan && c.disableZoom || (i[f] = function (b) { let d; (b.type === 'touchstart' ? !(d = b.touches || b.originalEvent.touches) || (d.length !== 1 || c.disablePan) && d.length !== 2 : c.disablePan || (b.which || b.originalEvent.which) !== c.which) || (b.preventDefault(), b.stopPropagation(), a._startMove(b, d)) }, c.which === 3 && (i.contextmenu = !1)), this.$elem.on(i), j.length && j.on(h, (b) => { b.preventDefault(), a.reset() }), k.length && k.attr({ step: c.rangeStep === g.defaults.rangeStep && k.attr('step') || c.rangeStep, min: c.minScale, max: c.maxScale }).prop({ value: this.getMatrix()[0] }), !c.disableZoom) {
        const m = this.$zoomIn,
          n = this.$zoomOut; m.length && n.length && (m.on(h, (b) => { b.preventDefault(), a.zoom() }), n.on(h, (b) => { b.preventDefault(), a.zoom(!0) })), k.length && (i = {}, i[e] = function () { a.transition(!0) }, i[(l ? 'input' : 'change') + d] = function () { a.zoom(+this.value, { noSetRange: !0 }) }, k.on(i))
      }
    },
    _unbind() { this.$elem.add(this.$zoomIn).add(this.$zoomOut).add(this.$reset).off(this.options.eventNamespace) },
    _buildTransform() { return this._origTransform = this.getTransform(this.options.startTransform) },
    _buildTransition() { if (this._transform) { const a = this.options; this._transition = `${this._transform} ${a.duration}ms ${a.easing}` } },
    _getDistance(a) {
      const b = a[0],
        c = a[1]; return Math.sqrt(Math.pow(Math.abs(c.clientX - b.clientX), 2) + Math.pow(Math.abs(c.clientY - b.clientY), 2))
    },
    _getMiddle(a) {
      const b = a[0],
        c = a[1]; return { clientX: (c.clientX - b.clientX) / 2 + b.clientX, clientY: (c.clientY - b.clientY) / 2 + b.clientY }
    },
    _trigger(a) { typeof a === 'string' && (a = `panzoom${a}`), this.$elem.triggerHandler(a, [this].concat(j.call(arguments, 1))) },
    _startMove(a, d) {
      if (!this.panning) {
        let e, f, g, i, j, k, l, m,
          n = this,
          o = this.options,
          p = o.eventNamespace,
          q = this.getMatrix(),
          r = q.slice(0),
          s = +r[4],
          t = +r[5],
          u = { matrix: q, animate: 'skip' },
          v = a.type; v === 'pointerdown' ? (e = 'pointermove', f = 'pointerup') : v === 'touchstart' ? (e = 'touchmove', f = 'touchend') : v === 'MSPointerDown' ? (e = 'MSPointerMove', f = 'MSPointerUp') : (e = 'mousemove', f = 'mouseup'), e += p, f += p, this.transition(!0), this.panning = !0, this._trigger('start', a, d); const w = function (a, b) { if (b) { if (b.length === 2) { if (g != null) return; return g = n._getDistance(b), i = n.getScale(q), void (j = n._getMiddle(b)) } if (k != null) return; (m = b[0]) && (k = m.pageX, l = m.pageY) }k == null && (k = a.pageX, l = a.pageY) }; w(a, d); const x = function (a) {
          let b; if (a.preventDefault(), d = a.touches || a.originalEvent.touches, w(a, d), d) {
            if (d.length === 2) {
              const c = n._getMiddle(d),
                e = n._getDistance(d) - g; return n.zoom(e * (o.increment / 100) + i, { focal: c, matrix: q, animate: 'skip' }), n.pan(+q[4] + c.clientX - j.clientX, +q[5] + c.clientY - j.clientY, u), void (j = c)
            }b = d[0] || { pageX: 0, pageY: 0 }
          }b || (b = a), n.pan(s + b.pageX - k, t + b.pageY - l, u)
        }; b(h).off(p).on(e, x).on(f, function (a) { a.preventDefault(), b(this).off(p), n.panning = !1, a.type = 'panzoomend', n._trigger(a, q, !c(q, r)) })
      }
    },
  }, b.Panzoom = g, b.fn.panzoom = function (a) { let c, d, e, f; return typeof a === 'string' ? (f = [], d = j.call(arguments, 1), this.each(function () { c = b.data(this, i), c ? a.charAt(0) !== '_' && typeof (e = c[a]) === 'function' && void 0 !== (e = e.apply(c, d)) && f.push(e) : f.push(void 0) }), f.length ? f.length === 1 ? f[0] : f : this) : this.each(function () { new g(this, a) }) }, g
}))
